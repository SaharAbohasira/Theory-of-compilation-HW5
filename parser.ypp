%{
        #include <iostream>
        #include "hw3_output.hpp"
        #include "types.h"
        #include "symbol_table.h"
        #include "general.h"
        #include "cg.hpp"

        using namespace std;
        using namespace output;
        extern int yylineno;
        extern int yylex();
        extern ScopeSymbolTable scopeSymbolTable;
        extern CodeBuffer buffer;
        extern general codeGenerator;
        vector<string> whileNextStack;
        vector<string> whileLabelStack;
        int yyerror(const char * merror);
%}

%nonassoc INT BYTE B BOOL TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC ID NUM STRING COMMA

%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELATIONAL
%left ADD_SUB
%left MULT_DIV
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE

%%

Program: Statements                                             {$$ = new Program();}

Statements: Statement                                           {$$ = new Statements(dynamic_cast<Statement*>($1));}
            | Statements Statement                              {$$ = new Statements(dynamic_cast<Statements*>($1),dynamic_cast<Statement*>($2));}

Statement: LBRACE {/*std::cout << "start scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.push_scope();} Statements {/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope();} RBRACE                            {$$ = $2;}
           | Type ID SC                                         {$$ = new Statement(dynamic_cast<Type*>($1), $2);}
           | Type ID ASSIGN Exp SC                              {$$ = new Statement(dynamic_cast<Type*>($1), $2, dynamic_cast<Exp*>($4));}
           | ID ASSIGN Exp SC                                   {$$ = new Statement($1, dynamic_cast<Exp*>($3));}
           | Call SC                                            {$$ = new Statement(dynamic_cast<Call*>($1));}
           | RETURN SC                                          {$$ = new Statement(new Exp(), true);}
           | IF LPAREN ISBOOL RPAREN PUSH Label Statement                     {$$ = new Statement("IF", $3);/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope(); buffer.emit(dynamic_cast<Label*>($6)->false_label + ":");}
           | IF LPAREN ISBOOL RPAREN PUSH Label {dynamic_cast<Exp*>($3)->true_label = dynamic_cast<Label*>($6)->true_label; dynamic_cast<Exp*>($3)->false_label = dynamic_cast<Label*>($6)->false_label; codeGenerator.if_else_code(dynamic_cast<Exp*>($3), dynamic_cast<Label*>($6));} Statement ELSE {/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope(); buffer.emit("br label3 " + dynamic_cast<Label*>($6)->next_label); buffer.emit(dynamic_cast<Label*>($6)->false_label + ":");} PUSH Statement      {$$ = new Statement("IF_ELSE", $3);/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope(); buffer.emit(dynamic_cast<Label*>($6)->next_label + ":");}
           | WHILE LPAREN {dynamic_cast<Statement*>($$)->whileLabel = buffer.freshLabel(); whileLabelStack.push_back(dynamic_cast<Statement*>($$)->whileLabel);} ISBOOL {whileNextStack.push_back(dynamic_cast<Exp*>($3)->false_label);} RPAREN {/*std::cout << "start scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.push_scope(true); buffer.emit(dynamic_cast<Exp*>($3)->true_label + ":");} Statement                  {$$ = new Statement("WHILE", $3);/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope(); buffer.emit("br label4 " + dynamic_cast<Statement*>($$)->whileLabel); buffer.emit(dynamic_cast<Exp*>($3)->false_label + ":"); whileLabelStack.pop_back();}
           | BREAK SC                                           {$$ = new Statement($1); buffer.emit("br label1" + whileNextStack.back()); whileNextStack.pop_back();}
           | CONTINUE SC                                        {$$ = new Statement($1); buffer.emit("br label2" + whileLabelStack.back());}

Call: ID LPAREN Exp RPAREN                                {$$ = new Call($1, $3);}

Type: INT                                                       {$$ = new Type("int");}
      | BYTE                                                    {$$ = new Type("byte");}
      | BOOL                                                    {$$ = new Type("bool");}


Exp: LPAREN Exp RPAREN                                          {$$ = new Exp(dynamic_cast<Exp*>($2));}
     | Exp MULT_DIV Exp                                         {$$ = new Exp($1, $3, $2->value, "binop");}
     | Exp ADD_SUB Exp                                          {$$ = new Exp($1, $3, $2->value, "binop");}
     | ID                                                       {$$ = new Exp($1, true);}
     | Call                                                     {$$ = new Exp($1, false);}
     | NUM                                                      {$$ = new Exp("int", $1);}
     | NUM B                                                    {$$ = new Exp("byte", $1);}
     | STRING                                                   {$$ = new Exp("string", $1);}
     | TRUE                                                     {$$ = new Exp("bool", $1);}
     | FALSE                                                    {$$ = new Exp("bool", $1);}
     | NOT Exp                                                  {$$ = new Exp($2, $2, $1->value, "bool");}
     | Exp AND Exp                                              {$$ = new Exp($1, $3, $2->value, "bool");}
     | Exp OR Exp                                               {$$ = new Exp($1, $3, $2->value, "bool");}
     | Exp RELATIONAL Exp                                       {$$ = new Exp($1, $3, $2->value, "relop");}
     | Exp EQUALITY Exp                                         {$$ = new Exp($1, $3, $2->value, "relop");}
     | LPAREN Type RPAREN Exp                                   {$$ = new Exp(dynamic_cast<Type*>($2), dynamic_cast<Exp*>($4));}

PUSH:                                                           {/*std::cout << "start scope line: " << yylineno << std::endl;*/ scopeSymbolTable.push_scope();}
ISBOOL: Exp                                                     {is_bool($1);}
Label:                                                          {$$ = new Label();}
%%

CodeBuffer buffer = CodeBuffer();
ScopeSymbolTable scopeSymbolTable = ScopeSymbolTable();
general codeGenerator = general();

int main(){
    buffer.initialEmits();
    buffer.emit("define i32 @main(){");
    int parse = yyparse();
    scopeSymbolTable.pop_scope();
    buffer.emit("ret i32 0");
    buffer.emit("}");
    buffer.printGlobalBuffer();
    buffer.printCodeBuffer();
    return parse;
}

int yyerror(const char * merror){
    errorSyn(yylineno);
    exit(0);
}