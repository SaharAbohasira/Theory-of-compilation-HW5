%{
        #include <iostream>
        #include "hw3_output.hpp"
        #include "types.h"
        #include "symbol_table.h"

        using namespace std;
        using namespace output;
        extern int yylineno;
        extern int yylex();
        extern ScopeSymbolTable scopeSymbolTable;
        int yyerror(const char * merror);
%}

%nonassoc INT BYTE B BOOL TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC ID NUM STRING COMMA

%right ASSIGN
%left OR
%left AND
%left EQUALITY
%left RELATIONAL
%left ADD_SUB
%left MULT_DIV
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE

%%

Program: Statements                                             {$$ = new Program();}

Statements: Statement                                           {$$ = new Statements(dynamic_cast<Statement*>($1));}
            | Statements Statement                              {$$ = new Statements(dynamic_cast<Statements*>($1),dynamic_cast<Statement*>($2));}

Statement: LBRACE {/*std::cout << "start scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.push_scope();} Statements {/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope();} RBRACE                            {$$ = $2;}
           | Type ID SC                                         {$$ = new Statement(dynamic_cast<Type*>($1), $2);}
           | Type ID ASSIGN Exp SC                              {$$ = new Statement(dynamic_cast<Type*>($1), $2, dynamic_cast<Exp*>($4));}
           | ID ASSIGN Exp SC                                   {$$ = new Statement($1, dynamic_cast<Exp*>($3));}
           | Call SC                                            {$$ = new Statement(dynamic_cast<Call*>($1));}
           | RETURN SC                                          {$$ = new Statement(new Exp(), true);}
           | IF LPAREN ISBOOL RPAREN PUSH Statement                     {$$ = new Statement("IF", $3);/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope();}
           | IF LPAREN ISBOOL RPAREN PUSH Statement ELSE {/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope();} PUSH Statement      {$$ = new Statement("IF_ELSE", $3);/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope();}
           | WHILE LPAREN ISBOOL RPAREN {/*std::cout << "start scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.push_scope(true);} Statement                  {$$ = new Statement("WHILE", $3);/*std::cout << "end scope line: " << yylineno<< std::endl;*/ scopeSymbolTable.pop_scope();}
           | BREAK SC                                           {$$ = new Statement($1);}
           | CONTINUE SC                                        {$$ = new Statement($1);}

Call: ID LPAREN Exp RPAREN                                {$$ = new Call($1, $3);}    //TODO: check if need dynamic cast

Type: INT                                                       {$$ = new Type("int");}
      | BYTE                                                    {$$ = new Type("byte");}
      | BOOL                                                    {$$ = new Type("bool");}


Exp: LPAREN Exp RPAREN                                          {$$ = new Exp(dynamic_cast<Exp*>($2));}
     | Exp MULT_DIV Exp                                         {$$ = new Exp($1, $3, $2->value, "binop");}
     | Exp ADD_SUB Exp                                          {$$ = new Exp($1, $3, $2->value, "binop");}
     | ID                                                       {$$ = new Exp($1, true);}
     | Call                                                     {$$ = new Exp($1, false);}
     | NUM                                                      {$$ = new Exp("int", $1);}
     | NUM B                                                    {$$ = new Exp("byte", $1);}
     | STRING                                                   {$$ = new Exp("string", $1);}
     | TRUE                                                     {$$ = new Exp("bool", $1);}  //TODO:
     | FALSE                                                    {$$ = new Exp("bool", $1);}
     | NOT Exp                                                  {$$ = new Exp($2, $2, $1->value, "bool");}  //TODO:
     | Exp AND Exp                                              {$$ = new Exp($1, $3, $2->value, "bool");}
     | Exp OR Exp                                               {$$ = new Exp($1, $3, $2->value, "bool");}
     | Exp RELATIONAL Exp                                       {$$ = new Exp($1, $3, $2->value, "relop");}  //TODO:
     | Exp EQUALITY Exp                                         {$$ = new Exp($1, $3, $2->value, "relop");}
     | LPAREN Type RPAREN Exp                                   {$$ = new Exp(dynamic_cast<Type*>($2), dynamic_cast<Exp*>($4));}     //TODO:

PUSH:                                                           {/*std::cout << "start scope line: " << yylineno << std::endl;*/ scopeSymbolTable.push_scope();}
ISBOOL: Exp                                                     {is_bool($1);}
%%

ScopeSymbolTable scopeSymbolTable = ScopeSymbolTable();

int main(){
    int parse = yyparse();
    scopeSymbolTable.pop_scope();
    return parse;
}

int yyerror(const char * merror){
    errorSyn(yylineno);
    exit(0);
}